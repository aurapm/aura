\documentclass{article}
% GENERAL
\usepackage[usenames,dvipsnames]{color}
\usepackage{setspace,graphicx,fancyhdr,hyperref,amsmath,tikz,epigraph}
\usepackage{framed,listings,comment}
\usepackage[utf8]{inputenc}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  keepspaces=true,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it\color{orange},
  stringstyle=\mdseries\rmfamily\color{red},
  showspaces=false,
  keywordstyle=\bfseries\rmfamily\color{blue},
  flexiblecolumns=false,
  basicstyle=\small\sffamily,
  showstringspaces=true,
  morecomment=[l]\%
}

% FONT
\usepackage{arev}
\usepackage[T1]{fontenc}

% MARGINS
\usepackage[left=1in,top=1in,right=1in,bottom=1in]{geometry}
\onehalfspacing

% CUSTOM FOOTERS
\pagestyle{fancy}
\fancyhead{}                        % clear all header fields
\renewcommand{\headrulewidth}{0pt}  % no line in header area
\fancyfoot{}                        % clear all footer fields
\fancyfoot[LE,RO]{\thepage}         % for page #s
%\fancyfoot[RE,LO]{\includegraphics[scale=0.03]{adenda-logo}}

% Setting the depth for Table of Contents
\setcounter{tocdepth}{3}

\begin{document}
\definecolor{shadecolor}{gray}{0.9}

% --- TABLE OF CONTENTS ---
\tableofcontents
\clearpage
% -------------------------

Aura 2 Design

\section{Preface}\label{preface}

This is a design document for version 2 of
\href{https://github.com/fosskers/aura}{Aura}. Note that specifications
are written in present tense, as in, ``Aura does this'' even if at the
time of writing those features aren't implemented yet. This is to ensure
that the document can act as a reference for Aura's behaviour
post-release.

\section{Mission Statement}\label{mission-statement}

Aura is a cross-distribution package manager for GNU/Linux systems. It
is based around a distribution-specific Hook system for custom
build/install behaviour, while maintaining a custom interface across all
distros. Aura itself provides:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Dependency management.
\item
  Package downloading.
\item
  Package-state backups/restoration.
\end{itemize}

Aura's authors recognize that \href{http://www.xkcd.com/927/}{attemping
to create universal standards can be problematic}, but that is precisely
why Aura exists. By having a unified interface over multiple packaging
standards, users can transition between distributions more easily, and
distribution developers can avoid reinventing the wheel by writing their
own package management software.

\section{Functionality}
\colorbox{GreenYellow}{Paths are GreenYellow.}\\
\colorbox{SkyBlue}{Haskell function signatures are SkyBlue.}\\
\colorbox{Apricot}{CLI flags/commands are Apricot.}
\colorbox{Red}{TODOs / Decisions to make.}

\subsection{General}
Aura handles three types of packages:
\begin{itemize}
  \item Repository Packages: Prebuilt binaries available
    direct from the user's Distribution.
  \item Foreign Packages: Packages that generally need to be compiled
    by the user. Their versioning/source locations may be managed
    by the Distribution is some way.
  \item Local Packages: Packages installed on the user's system.
    Records of them and the files belonging to them are stored in a
    database, and package files themselves are stored in a cache
    (in \colorbox{GreenYellow}{/var/cache/} or elsewhere).
\end{itemize}
A number of operations can be performed on these package types,
as explained below.

% --- %

\subsubsection{Repository Package Installation}
Aura allows installation of prebuilt binaries from mirrors
defined in \hyperref[auraconf]{AuraConf}.\\
Usage: \colorbox{Apricot}{\texttt{aura -S <packages>}}\\

% --- %

\subsubsection{Foreign Package Installation}
Aura allows installation of foreign packages, prebuilt or to be
compiled, from locations defined by Hooks in \hyperref[auraconf]{AuraConf}.\\
Not all distributions may support this type of installation.\\
Usage: \colorbox{Apricot}{\texttt{aura -A <packages>}}

% --- %

\subsubsection{Local Package Removal}
Installed packages may be removed singularly, or in groups.\\
Usage:
\begin{itemize}
  \item Just the packages named: \colorbox{Apricot}{\texttt{aura -R <packages>}}
  \item Packages named and all deps (recursive):
    \colorbox{Apricot}{\texttt{aura -Rr <packages>}}
\end{itemize}

% --- %

\subsubsection{Package Search}
Searches on all three package types can be performed. A regular
expression is given to search on.\\
Usage:
\begin{itemize}
  \item Search repository packages: \colorbox{Apricot}{aura -Ss <pattern>}
  \item Search foreign packages: \colorbox{Apricot}{aura -As <pattern>}
  \item Search local packages: \colorbox{Apricot}{aura -Qs <pattern>}
\end{itemize}
Aura will fail silently when no pattern is given.\\
Output sample:
\begin{shaded}
\begin{verbatim}
extra/nvidia 337.25-3 [installed]
    NVIDIA drivers for linux
extra/nvidia-304xx 304.121-5
    NVIDIA drivers for linux, 304xx legacy branch
extra/nvidia-304xx-libgl 304.121-2
    NVIDIA drivers libraries symlinks, 304xx legacy branch
\end{verbatim}
\end{shaded}

% --- %

\subsubsection{Package Information}
Queries for specific package information can be performed on all
three package types. The exact names of existing packages must be given.\\
Usage:
\begin{itemize}
  \item Query repository packages: \colorbox{Apricot}{aura -Si <packages>}
  \item Query foreign packages: \colorbox{Apricot}{aura -Ai <packages>}
  \item Query local packages: \colorbox{Apricot}{aura -Qi <packages>}
\end{itemize}

% --- %

\subsubsection{Local Package Backups}
The state of locally installed packages may be recorded and restored
at a later date.\\
Usage:
\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item Store a snapshot of all installed packages:
  \colorbox{Apricot}{\texttt{aura -B}}
  \begin{itemize}
    \item This record is stored in
      \colorbox{GreenYellow}{/var/cache/aura/states}.
    \item Filenames are of the form: \texttt{YYYY.MM(MonthName).DD.HH.MM}
    \item The data itself is stored as JSON to ease use by other tools
      (seen below).
  \end{itemize}
\item Restore a snapshot: \colorbox{Apricot}{\texttt{aura -Br}}
\end{itemize}

\begin{shaded}
\begin{lstlisting}[language=haskell]
{ ``date'': ``2014-04-09'',
  ``time'': ``20:00'',
  ``packages'': [ { ``pkgname'': ``alsa-lib'',
                    ``version'': ``1.0.27.2-1'' },
                // more packages here
                ]
}
\end{lstlisting}
\end{shaded}

% --- %

\subsection{Packages Update information}

Whenever Aura needs to update packages, it should display the upcoming updates
in a clear and easy to read format. Those information will be displayed for
either \colorbox{Apricot}{aura -Syu} or \colorbox{Apricot}{aura -Ayu}.

When multiple packages versions have to be displayed, lines should be aligned
on the “\texttt{-\/->}” symbol.

\subsubsection{New package dependency needed}

If a new package has to be installed because it is a new dependency of an
already installed package, aura should display the following information:

\begin{shaded}
\begin{verbatim}
== New package needed:
community/pyzy        1.0-1            (required by ibus-pinyin)
\end{verbatim}
\end{shaded}

% --- %

\subsubsection{New package release}

This information is displayed whenever a package release has been updated. In
other words, when the number after the last dash has increased.

Note that the number changed is coloured such as: (I have used an xml's syntax
to indicate where the colour should be)

\begin{shaded}
\begin{verbatim}
== New package release:
community/pyzy        1.0-1    -->    1.0-<green>2</green>
\end{verbatim}
\end{shaded}

% --- %

\subsubsection{New package version}

This information is displayed whenever a package's version has been updated.

Nothe that the number changed is coloured such as: (I have used an xml's syntax
to indicate where the colour should be)

\begin{shaded}
\begin{verbatim}
== New package version:
community/pyzy        1.0-1    -->    1.<green>2-1</green>
\end{verbatim}
\end{shaded}

% --- %

\subsection{Other}
\begin{comment}
\subsubsection{Program Flow}\label{program-flow}

\textbf{This section needs reorganising}

Execution in Aura takes the following order:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Parse command-line options.
\item
  Collect local \texttt{Setting}s.
\item
  Branch according to capital letter operator (\texttt{-\{S,A,Q,...\}}):
\end{enumerate}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{-S \textless{}packages\textgreater{}}:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    A \textbf{Hook} provides functions:
  \item
    \texttt{Monad m =\textgreater{} {[}Text{]} -\textgreater{} m ({[}Text{]},{[}Package{]})}
  \item
    \texttt{Monad m =\textgreater{} Text -\textgreater{} m (Either Text Package)}
  \end{itemize}

  The former can be defined in the terms of the latter, but doesn't have
  to be if that method executes faster. The first function is given the
  names of all packages to be installed. The \texttt{{[}Text{]}} are
  packages that don't exist. They are reported.

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    With the output of the last function, resolve dependencies by Aura's
    internal algorithm to receive:
    \texttt{Either PkgGraph {[}{[}Package{]}{]}}.
  \item
    On \texttt{Left}, analyse the given \texttt{PkgGraph}, yield output
    as described in \href{/DESIGN.md\#dependency-resolution}{Dependency
    Resolution}, and quit.
  \item
    On \texttt{Right} display a chart as described
    \href{/DESIGN.md\#version-information-when-upgrading}{here}.
  \item
    Download each package via Aura's internal algorithm.
  \item
    A \textbf{Hook} provides an install function
    \texttt{MonadError m =\textgreater{} {[}{[}Package{]}{]} -\textgreater{}   m ()}
  \end{itemize}
\item
  \texttt{-\{S,A,Q\}i \textless{}packages\textgreater{}}:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Call a \textbf{Hook} that provides
    \texttt{Monad m =\textgreater{} Text -\textgreater{} m PkgInfo}. The
    contents of the \texttt{PkgInfo} ADT are described
    \href{/DESIGN.md\#pkginfo}{here}.
  \item
    Aura gives output according to the \texttt{PkgInfo}.
  \end{itemize}
\item
  \texttt{-\{S,A,Q\}s \textless{}pattern\textgreater{}}:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Call a \textbf{Hook} that provides
    \texttt{Monad m =\textgreater{} Text -\textgreater{} m {[}PkgInfo{]}}.
    Where the \texttt{Text} is a pattern to be searched for.
  \item
    Aura gives output according to the \texttt{{[}PkgInfo{]}}.
  \end{itemize}
\end{itemize}
\end{comment}

\subsubsection{Dependency Resolution}\label{dependency-resolution}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  AUR dependencies are no longer resolved through PKGBUILD bash parsing.
  The AUR 3.x API includes the necessary dependency information.
\item
  \textbf{Resolution Successful}: Data in the form
  \colorbox{SkyBlue}{\texttt{{[}{[}Package{]}{]}}} is yielded. These are groups of packages
  that may be built and installed simultaneously. That is, they are not
  interdependent in any way.
\item
  \textbf{Version Conflicts}:
\item
  Dependency resolution fails and the build does not continue.
\item
  The user is shown the chart below so it is clear what dependencies
  from what packages are causing issues.
\item
  All packages that had dependency issues are shown.
\item
  Supplying the \texttt{-\/-json} flag will output this data as JSON for
  capture by other programs.
\end{itemize}

\begin{verbatim}
| Dep Name | Parent | Status   | Version |
| -------- | ------ | -------- | ------- |
| foo      | None   | Local    | 1.2.3   |
| foo      | bar    | Incoming | < 1.2.3 |
| foo      | baz    | Incoming | > 1.2.3 |
| -------- | ------ | -------- | ------- |
| curl     | git    | Local    | 7.36.0  |
| curl     | pacman | Incoming | 7.37.0  |
| -------- | ------ | -------- | ------- |
| lua      | vlc    | Incoming | 5.2.3   |
| lua      | conky  | Incoming | 5.2.2   |
\end{verbatim}

\begin{shaded}
\begin{lstlisting}[language=haskell]
// As JSON:
{ [ { ``Name'': ``foo'',
      ``Local'': { ``Parent'': ``None'',
                   ``Version'': ``1.2.3'' },
      ``Incoming'': [ { ``Parent'': ``bar'',
                        ``Version'': ``< 1.2.3'' },
                      { ``Parent'': ``baz'',
                        ``Version'': ``> 1.2.3'' }
                    ]
    },
    { ``Name'': ``curl'',
      ``Local'': { ``Parent'': ``git''
                 , ``Version'': ``7.36.0'' },
      ``Incoming'': [ { ``Parent'': ``pacman'',
                        ``Version'': ``7.37.0'' }
                    ]
    },
    { ``Name'': ``lua'',
      ``Local'': ``None'',
      ``Incoming'': [ { ``Parent'': ``vlc'',
                        ``Version'': ``5.2.3'' },
                      { ``Parent'': ``conky'',
                        ``Version'': ``5.2.2'' }
                    ]
    }
  ]
}
\end{lstlisting}
\end{shaded}

\subsubsection{Dependency Information Output}\label{dependency-information-output}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Information for all immediate dependencies for any given package can
  be output in human-readable format by default with \texttt{-\{A,S\}d}.
\item
  Adding \texttt{-\/-recursive} will yield all dependencies and
  \emph{their} dependencies as well.
\item
  Adding \texttt{-\/-json} will output this information in JSON for use
  by other software that may sit on top of Aura.
\end{itemize}

\subsubsection{Concurrent Package
Building}\label{concurrent-package-building}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Package data is returned from dependency checking in the form
  \texttt{{[}{[}Package{]}{]}} (see
  \href{/DESIGN.md\#dependency-resolution}{Dependency Resolution}). Each
  sublist of packages have no interdependencies, so they are built
  concurrent to each other and then installed as a block.
\end{itemize}

\subsubsection{PkgInfo}\label{pkginfo}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{-\{S,A,Q\}i} yields \texttt{PkgInfo} data. It holds:
\item
  Repository name
\item
  Package name
\item
  Version
\item
  Description
\item
  Architecture
\item
  URL
\item
  Licenses
\item
  ``Provides''
\item
  Dependencies
\item
  ``Conflicts With''
\item
  Maintainer
\item
  Optional fields (provided as \texttt{{[}(Text,Text){]}}):

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Download/Install sizes
  \item
    Group
  \item
    Votes
  \item
    GPG information
  \item
    etc.
  \end{itemize}
\end{itemize}

\subsubsection{Abnormal Termination}\label{abnormal-termination}
Users can halt Aura with \texttt{Ctrl-d}. The message
\texttt{Stopping Aura...} is shown. All temporary files in use are
cleared here.

\subsubsection{Colour Output}\label{colour-output}
All output to terminal (save JSON data) is output in colour where
appropriate. The user can disable this with
\colorbox{Apricot}{\texttt{-\/-no-colo\{ur,r\}}}

\subsubsection{Usage Tips}
The user is shown usage tips when waiting for dependencies to resolve, etc.
A number of tips are Aura-centric, but distro-specific ones can be defined
in \hyperref[auraconf]{AuraConf}.\\
\colorbox{Red}{TODO: Decide frequency and what command(s) cause these
tips to appear.}

% === %

\subsection{Plugins}\label{plugins}
Like XMonad, behaviour is built around hooks/plugins that are themselves
written in Haskell. Each Linux distribution writes and provides to
\texttt{AuraConf.hs} functions that fill certain type/behaviour
requirements as explained below.

\subsubsection{AuraConf}\label{auraconf}
\texttt{AuraConf.hs} is Aura's configuration file. It is typically
located in \colorbox{Red}{\texttt{TODO: LOCATION HERE}.} Here, distributions
and users
can add Hooks to define custom behaviour for their native packaging
system. The command \colorbox{Apricot}{\texttt{aura -\/-recompile}}
rebuilds Aura with new
Hooks. Also, the following paths can be defined in this file:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Package cache.
\item
  Aura log file.
\item
  Default build directory.
\item
  Mirror URLs for binary downloads.
\item
  TODO: What else?
\end{itemize}

\subsubsection{Hook List}\label{hook-list}

Pending.

\subsection{Aesthetics}\label{aesthetics}

\subsubsection{Localisation}
Aura is available for use in multiple languages. Language can be set
via environment variables \colorbox{Red}{(Which ones?)} or by using
Aura flags that correspond to that language. Note that use of a flag
will override whatever environment variable is set. Each language has an
English name and its native equivalent (accents and other non-ascii characters
are compatible). For example:
\begin{itemize}
  \item \colorbox{Apricot}{\texttt{-\/-croatian}} and
    \colorbox{Apricot}{\texttt{-\/-hrvatski}}
  \item \colorbox{Apricot}{\texttt{-\/-french}}and
    \colorbox{Apricot}{\texttt{-\/-français}}
% TODO:  \item \colorbox{Apricot}{--japanese} and \colorbox{Apricot}{--日本語}
\end{itemize}

\subsubsection{Version Information when
Upgrading}\label{version-information-when-upgrading}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Need a nice chart.
\end{itemize}

\subsubsection{Aura Versioning}\label{aura-versioning}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Aura uses \href{http://semver.org/}{Semantic Versioning}, meaning it's
  version numbers are of the form \texttt{MAJOR.MINOR.PATCH}.
\end{itemize}

\subsection{Haskell Requirements}\label{haskell-requirements}

\subsubsection{Strings}\label{strings}
All Strings are represented as \colorbox{SkyBlue}{\texttt{Text}} from
\texttt{Data.Text}.
This is available in the \texttt{text} package from Hackage. The following
language pragma should be used where appropriate for String literals being
converted to \colorbox{SkyBlue}{\texttt{Text}} automatically:

\begin{shaded}
\begin{lstlisting}[language=haskell]
{-# LANGUAGE OverloadedStrings #-}
\end{lstlisting}
\end{shaded}

\subsubsection{JSON Data}\label{json-data}
All JSON input and output is handled through the \texttt{aeson} and
\texttt{aeson-pretty} packages.

\subsubsection{Parsing}
All parsing is done with Parsec. Regular Expressions are no longer used
anywhere in Aura.\\
\colorbox{Red}{Parsec or Attoparsec?}

\subsubsection{Other Libraries}\label{other-libraries}
Information on other Hackage libraries used in Aura can be found
\href{https://github.com/fosskers/aura/issues/223}{here}.

\subsection{Package Requirements}\label{package-requirements}
Aura must be available in the following forms:
\begin{itemize}
  \item \texttt{haskell-aura}\\
    An AUR package pulled from Hackage, contains only the Aura ``shell'' layer.
    The user must install another package to get the Arch Linux Hooks, and
    then build the executable themselves.
  \item \texttt{aura}\\ Official Arch-flavoured Aura, built and configured
    in a cabal sandbox. \emph{cabal-install} is the only Haskell related
    dependency.
  \item \texttt{haskell-aura-git}\\ Most recent version of Aura, as found
    on its source repository.
  \item \texttt{aura-legacy}\\
    A static copy of Aura 1. Has Haskell dependencies.
\end{itemize}

% === %

\section{Arch Linux Specifics}\label{arch-linux-specifics}

\subsubsection{ABS Package
Building/Installation}\label{abs-package-buildinginstallation}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  There is no longer a \texttt{-M} option. All ABS package interaction
  is done through \texttt{-S}.
\item
  Installs prebuilt binaries available from Arch servers by default.
\item
  Build options:
\item
  If the user specifies \texttt{-\/-build}, the package will be built
  manually via the ABS.
\end{itemize}

\subsubsection{AUR Package
Building/Installation}\label{aur-package-buildinginstallation}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Builds manually by default, as there is no prebuilt alternative for
  the AUR (by design).
\end{itemize}

\subsubsection{PKGBUILD/Additional Build-file
Editing}\label{pkgbuildadditional-build-file-editing}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Support for \texttt{customizepkg} is dropped, as AUR 3.x provides
  dependency information via its API.
\item
  Users can edit included \texttt{.install} files and the
  \textbf{behaviour} of PKGBUILDs with \texttt{-\/-edit}. This is done
  after dependency checks have been made via the data from the AUR API.
  Users are urged \emph{not} to edit dependencies at this point, as only
  \texttt{makepkg}, not Aura, will know about the changes.
\item
  If you do want to build a package with different dependencies,
  consider whether there is value in creating your own forked package
  for the AUR (named \texttt{foo-legacy}, etc.). Others may benefit from
  your effort.
\item
  If you are trying to fix a broken package, rather than circumventing
  the problem by building manually with \texttt{makepkg}, please contact
  the maintainer.
\end{itemize}

\subsubsection{AUR Interaction}\label{aur-interaction}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  AUR API calls are moved out of Aura and into a new Hackage package
  \texttt{aur} (exposing the \texttt{Linux.Arch.Aur.*} modules).
\item
  It provides conversions to and from JSON data and Haskell data.
\item
  This is preparation for future versions of Aura that allow use in
  other Linux distributions by swapping out sections of their back-end
  (with modules like \texttt{Linux.Debian.Repo} etc.)
\end{itemize}

\section{Coding Standards}\label{coding-standards}

\subsection{Record Syntax}\label{record-syntax}

When using record syntax for ADTs, function names should be suffixed
with ``Of'' to reflect their noun-like nature:

\begin{shaded}
\begin{lstlisting}[language=haskell]
data Package = Package { nameOf    :: String
                       , versionOf :: Version
                       , depsOf    :: [Package] }
                       deriving (Eq, Show)
\end{lstlisting}
\end{shaded}

\end{document}
